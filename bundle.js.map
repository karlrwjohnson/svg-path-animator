{"version":3,"sources":["webpack:///webpack/bootstrap b19854bbb91f94ca6542","webpack:///./lib/util.js","webpack:///./lib/asyncExec.js","webpack:///./lib/pathParser.js","webpack:///./lib/math.js","webpack:///./lib/pathDataCommands.js","webpack:///./main.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;AChEA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA,gGAAgG,SAAS,kBAAkB;AAC3H;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gCAAgC,YAAY,WAAW,wBAAwB,SAAS,mBAAmB;AAC3G;;;;;;;;;;ACxCA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;;;;;;;;;;ACxCC;;AAED;AACA;AACA,iBAAiB,QAAQ,gBAAgB,MAAM,OAAO,WAAW;AACjE;AACA;AAAA;AAAA;;AAEA;AACA;AACA,iBAAiB,QAAQ,cAAc,MAAM,iBAAiB,MAAM,OAAO,WAAW;AACtF;AACA;AAAA;AAAA;;AAEA;AACA,0BAA0B,uBAAuB;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2EAA2E,uBAAuB;AAClG;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA,0DAA0D,cAAc;AACxE;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,qDAAqD,+BAA+B,kBAAkB;AAClI;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+GAAoD;AACpD,+GAAoD;AACpD,+GAAoD;AACpD,+GAAoD;AACpD,sHAA2D;AAC3D,sHAA2D;AAC3D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,4DAA4D,kBAAkB,IAAI,UAAU;AAC5F;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;;;;;;;;AC9LqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO,IAAI,OAAO;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA,uHAAiD,EAAE;AACnD,wHAAkD,EAAE;;AAEpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO,IAAI,OAAO;AACrC;AACA;AAAA;AAAA;;;;;;;;;;ACzEqB;AACG;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW,GAAG,WAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc,GAAG,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW,GAAG,WAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc,GAAG,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe,GAAG,eAAe,GAAG,eAAe,GAAG,eAAe,GAAG,WAAW,GAAG,WAAW;AACpH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB,GAAG,kBAAkB,GAAG,kBAAkB,GAAG,kBAAkB,GAAG,cAAc,GAAG,cAAc;AACtI;;AAEA;AACA,oBAAoB,yCAAyC;AAC7D,oBAAoB,yCAAyC;AAC7D,oBAAoB,qCAAqC;;AAEzD;AACA,qBAAqB;AACrB,qBAAqB;AACrB,qBAAqB;AACrB;AAAA;AAAA;;;;;;;;;;;;AC9R6B;AACL;AACH;;AAErB,oCAAoC;AACpC;;AAEA,4BAA4B;AAC5B,uBAAuB;AACvB,2BAA2B;;AAE3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,0CAA0C,gBAAgB;AAC1D;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB;AACA,iDAAiD;AACjD,4HAA6C;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b19854bbb91f94ca6542","export const SVGNS = 'http://www.w3.org/2000/svg';\n\nexport function getTypeName (thing) {\n    if (typeof thing === 'object') {\n        if (thing === null) {\n            return '(null)';\n        } else {\n            return thing.constructor.name;\n        }\n    } else {\n        return typeof thing;\n    }\n}\n\nexport function assertType (description, thing, ...types) {\n    if (types.length === 0) {\n        throw new Error(`Bad call to assertType(): At least one type must be specified`);\n    }\n\n    for (let type of types) {\n        if (typeof type === 'function') {\n            if (thing instanceof type) {\n                return;\n            }\n        } else if (typeof type === 'string') {\n            if (typeof thing === type) {\n                return;\n            }\n        } else {\n            // Type-checking in a type checker is meta\n            throw new Error(`Bad call to assertType(): All types must be a function or a string; got a ${getTypeName(type)}`);\n        }\n    }\n\n    const validTypeList = Array.from(types).map(t => (typeof t === 'function') ? t.name : t);\n    const formattedValidTypeList = (validTypeList.length === 1)\n        ? validTypeList[0]\n        : validTypeList.slice(0, -1).join(', a ') + ' or a ' + validTypeList.pop();\n\n    throw new Error(`Expected ${description} to be a ${formattedValidTypeList}; got a ${getTypeName(thing)}`);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/util.js\n// module id = 0\n// module chunks = 0","export default function asyncExec (generator) {\n    return new Promise((resolve, reject) => {\n        const iterator = generator();\n\n        function processIteration (iteration) {\n            // Generator has returned successfully\n            if (iteration.done) {\n                resolve(iteration.value);\n            }\n            // Generator has returned a promise\n            else if ('value' in iteration && iteration.value instanceof Promise) {\n                iteration.value.then(resumeGenerator, throwGenerator);\n            }\n            // Generator has mistakenly returned a non-promise value.\n            // Be forgiving and immediately resume execution\n            else {\n                resumeGenerator(iteration.value);\n            }\n        }\n\n        function resumeGenerator(value) {\n            try {\n                // Resume execution\n                processIteration(iterator.next(value));\n            } catch(e) {\n                // Catch errors that propagated out of the generator and\n                // pass them along to the promise.\n                reject(e);\n            }\n        }\n\n        function throwGenerator(error) {\n            try {\n                // Throw an exception within the generator where it last yielded\n                processIteration(iterator.throw(error));\n            } catch(e) {\n                reject(e);\n                // Catch errors that propagated out of the generator and\n                // pass them along to the promise.\n            }\n        }\n\n        resumeGenerator(undefined);\n    });\n}\n\nexport function timeout (milliseconds) {\n    return new Promise(resolve => setTimeout(resolve, milliseconds));\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/asyncExec.js\n// module id = 1\n// module chunks = 0","import {\n    ClosePathCommand,\n    AbsMoveCommand,\n    RelMoveCommand,\n    AbsLineCommand,\n    RelLineCommand,\n    AbsCubicSplineCommand,\n    RelCubicSplineCommand,\n} from './pathDataCommands';\n\nexport class LexerError extends Error {\n    constructor (message, index, dataString) {\n        super(`${message} at character ${index} of \"${dataString}\"`);\n    }\n}\n\nexport class ParserError extends Error {\n    constructor (message, token, index, dataString) {\n        super(`${message} for token '${token}' at character ${index} of \"${dataString}\"`);\n    }\n}\n\nexport function * lexPathData(dataString) {\n    for (let i = 0, j = 0; i < dataString.length; i = j) {\n        const chr = dataString[i];\n        switch(chr) {\n\n        // Single-letter commands\n        // (Quadratic splines, shorthand/\"smooth\" splines, and elliptical arcs not supported)\n        case 'M': case 'm': // Move To\n        case 'L': case 'l': // Line To\n        case 'C': case 'c': // Cubic Spline To\n        case 'Z': case 'z': // Close Path\n            yield [chr, i];\n            j = i + 1;\n            break;\n\n        // Unimplemented commands\n        case 'S': case 's': throw new LexerError(    '\"Smooth Cubic Spline To\" commands are not implemented.', i, dataString);\n        case 'Q': case 'q': throw new LexerError(       '\"Quadradic Spline To\" commands are not implemented.', i, dataString);\n        case 'T': case 't': throw new LexerError('\"Smooth Quadratic Spline To\" commands are not implemented.', i, dataString);\n        case 'A': case 'a': throw new LexerError(         '\"Elliptical Arc To\" commands are not implemented.', i, dataString);\n\n        // Numbers\n        // (Scientific notation not supported)\n        case '0': case '1': case '2': case '3': case '4':\n        case '5': case '6': case '7': case '8': case '9':\n        case '.': case '-':\n            {\n                // Seek to the end of the list of character which could conceivably be part of a number\n                for (j = i + 1;\n                    dataString[j] >= '0' && dataString[j] <= '9' || dataString[j] === '.';\n                    j++) {\n                    // no op\n                }\n\n                const number = parseFloat(dataString.slice(i, j));\n                if (isNaN(number)) {\n                    throw new LexerError(`Unable to parse a number from \"${dataString.slice(i, j)}\"`, i, dataString);\n                }\n\n                yield [number, i];\n            }\n            break;\n\n        // Whitespace and other separators\n        case ' ': case '\\t': case '\\r': case '\\n':\n        case ',': case ';':\n            j = i + 1;\n            break;\n\n        default:\n            throw new LexerError(`Unexpected character '${dataString[i]}'`, i, dataString);\n        }\n    }\n}\n\nexport function * parsePathData(dataString) {\n\n    let previousCommand = null;\n    let pathBeginCommand = null;\n    let commandClass = null;\n    let parameters = [];\n\n    function checkAllParametersUsed (token, index) {\n        if (parameters.length > 0) {\n            throw new ParserError(\n                `Expected ${commandClass.getParameterCount() - parameters.length} more parameters to complete ${commandClass.name} `,\n                index, token, dataString\n            );\n        }\n    }\n\n    for (let [token, index] of lexPathData(dataString)) {\n        if (typeof token === 'string') {\n            checkAllParametersUsed(token, index);\n\n            switch(token) {\n            case null:\n                break;\n\n            case 'M': commandClass = AbsMoveCommand; break;\n            case 'm': commandClass = RelMoveCommand; break;\n            case 'L': commandClass = AbsLineCommand; break;\n            case 'l': commandClass = RelLineCommand; break;\n            case 'C': commandClass = AbsCubicSplineCommand; break;\n            case 'c': commandClass = RelCubicSplineCommand; break;\n            case 'z': {\n                commandClass = ClosePathCommand;\n\n                // Finalize the command here since it doesn't take parameters\n                previousCommand = new ClosePathCommand(previousCommand, pathBeginCommand);\n                yield previousCommand;\n\n                break;\n            }\n\n            default:\n                throw new ParserError(`No command implemented`, token, index, dataString);\n            }\n        } else if (typeof token === 'number') {\n            parameters.push(token);\n\n            if (parameters.length >= commandClass.getParameterCount()) {\n\n\n                // Section 8.3.2 of the SVG Spec: (paraphrased)\n                //  - If a moveto command is followed by 1 or more extra pairs of\n                //    points, those pairs are to be interpreted as lineto commands.\n                //  - If the moveto command is absolute or relative, the implicit\n                //    lineto commands will also be absolute or relative.\n                //  - If a relative moveto appears at the beginning of a path data\n                //    string, it functions as an absolute moveto command, but any\n                //    implicit subsequent lineto commands will be relative.\n\n                // I'm making a decision to prioritize making it easy to interpret\n                // the resulting object model rather than preserve the exact parse\n                // tree of the original source code. If the SVG Spec contains\n                // optimizations to compress data on disk, this parser will return\n                // a simpler, semantically-equivalent data structure that does not\n                // contain those optimizations.\n\n                try {\n                    if (previousCommand === null && commandClass === RelMoveCommand) {\n                        previousCommand = AbsMoveCommand.fromParameters(\n                            previousCommand,\n                            parameters.splice(0, commandClass.getParameterCount())\n                        );\n                    } else {\n                        previousCommand = commandClass.fromParameters(\n                            previousCommand,\n                            parameters.splice(0, commandClass.getParameterCount())\n                        );\n                    }\n                } catch(e) {\n                    throw new ParserError(`Error creating ${commandClass.name}: ${e.message}`, token, index, dataString);\n                }\n\n                // Move-type commands warrant two different side effects\n                switch(commandClass) {\n                case AbsMoveCommand:\n                    // Switch to implicit line commands\n                    commandClass = AbsLineCommand;\n\n                    // SVG Spec Section 8.3.3: First moveto command in a data\n                    // string or following a close-path command resets the path\n                    // starting point to the moveto command's destination\n                    if (!previousCommand.previous || previousCommand.previous instanceof ClosePathCommand) {\n                        pathBeginCommand = previousCommand;\n                    }\n                    break;\n                case RelMoveCommand:\n                    commandClass = RelLineCommand;\n\n                    if (!previousCommand.previous || previousCommand.previous instanceof ClosePathCommand) {\n                        pathBeginCommand = previousCommand;\n                    }\n                    break;\n                default:\n                    break;\n                }\n\n                yield previousCommand;\n            }\n        } else {\n            throw new ParserError(`Unhandled token`);\n        }\n    }\n\n    checkAllParametersUsed('(EOF)', dataString.length);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/pathParser.js\n// module id = 2\n// module chunks = 0","import { assertType } from './util';\n\nexport class Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    equals(rhs) {\n        return rhs instanceof Point && this.x === rhs.x && this.y === rhs.y;\n    }\n    minus(rhs) {\n        assertType('RHS', rhs, Point, Vector);\n\n        if (rhs instanceof Point) {\n            return new Vector(this.x - rhs.x, this.y - rhs.y);\n        } else {\n            return new Point(this.x - rhs.x, this.y - rhs.y);\n        }\n    }\n    plus(vector) {\n        assertType('RHS', vector, Vector);\n\n        return new Point(this.x + vector.x, this.y + vector.y);\n    }\n    toString() {\n        return `(${this.x}, ${this.y})`;\n    }\n\n    static weightedAverage(...tuples) {\n        let x = 0;\n        let y = 0;\n        let i = 0;\n        for (let [point, weight] of tuples) {\n            assertType(`first element of tuple ${i}`, point, Point);\n            assertType(`second element of tuple ${i}`, weight, 'number');\n\n            x += point.x * weight;\n            y += point.y * weight;\n\n            i++;\n        }\n        return new Point(x, y);\n    }\n}\n\nexport class Vector {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    equals(rhs) {\n        return rhs instanceof Point && this.x === rhs.x && this.y === rhs.y;\n    }\n    plus(rhs) {\n        assertType('RHS', rhs, Point, Vector);\n\n        if (rhs instanceof Point) {\n            return new Point(this.x + rhs.x, this.y + rhs.y);\n        } else {\n            return new Vector(this.x + rhs.x, this.y + rhs.y);\n        }\n    }\n    times(rhs) {\n        assertType('RHS', rhs, 'number');\n\n        return new Vector(this.x * rhs, this.y * rhs);\n    }\n    get length () {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n    toString() {\n        return `<${this.x}, ${this.y}>`;\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/math.js\n// module id = 3\n// module chunks = 0","import { assertType } from './util';\nimport { Point, Vector } from './math';\n\nexport class Command {\n    constructor (previous) {\n        if (previous === undefined) {\n            throw new Error('Data must begin with an Absolute Move command');\n        }\n        this.previous = previous;\n    }\n    get begin () {\n        if (this.previous === null) {\n            throw new Error('Data began without a Move command');\n        }\n        return this.previous.end;\n    }\n    slice (_t) {\n        // Effectively no-op\n        return this;\n    }\n    interpolate (_t) {\n        return this;\n    }\n    hasLength() {\n        return true;\n    }\n    estimateLength() {\n        if (this.hasLength()) {\n            return this.end.minus(this.begin).length;\n        } else {\n            return 0;\n        }\n    }\n}\n\nexport class ClosePathCommand extends Command {\n    constructor (previous, returnTo) {\n        super(previous);\n\n        assertType('returnTo', returnTo, AbsMoveCommand, RelMoveCommand);\n        this.returnTo = returnTo;\n    }\n    get end() {\n        return this.returnTo.end;\n    }\n    static fromParameters () {\n        throw new Error('ClosePathCommand cannot be constructed from parameters');\n    }\n    static getParameterCount () {\n        return 0;\n    }\n    slice (t) {\n        return AbsLineCommand.prototype.slice.call(this, t);\n    }\n    toString() {\n        return 'z';\n    }\n}\n\nexport class AbsMoveCommand extends Command {\n    constructor (previous, end=null) {\n        super(previous || false);\n\n        this.end = end;\n    }\n    static fromParameters (previous, parameters) {\n        return new AbsMoveCommand(\n            previous,\n            new Point(...parameters.splice(0,2))\n        );\n    }\n    static getParameterCount () {\n        return 2;\n    }\n    get begin() {\n        return this.end;\n    }\n    toString() {\n        return `M${this.end.x},${this.end.y}`;\n    }\n    hasLength() {\n        return false;\n    }\n    // inherit no-op slice()\n}\n\nexport class RelMoveCommand extends Command {\n    constructor (previous, endRel=null) {\n        super(previous);\n\n        this.endRel = endRel;\n    }\n    static fromParameters (previous, parameters) {\n        return new RelMoveCommand(\n            previous,\n            new Vector(...parameters.splice(0,2))\n        );\n    }\n    static getParameterCount () {\n        return 2;\n    }\n    get begin() {\n        if (this.previous === false) {\n            return this.end;\n        } else {\n            return super.begin;\n        }\n    }\n    get end() {\n        return this.begin.plus(this.endRel);\n    }\n    toString() {\n        return `m${this.endRel.x},${this.endRel.y}`;\n    }\n    hasLength() {\n        return false;\n    }\n    estimateLength() {\n        return this.endRel.length;\n    }\n    // inherit no-op slice()\n}\n\nexport class AbsLineCommand extends Command {\n    constructor (previous, end=null) {\n        super(previous);\n\n        this.end = end;\n    }\n    static fromParameters (previous, parameters) {\n        return new AbsLineCommand(\n            previous,\n            new Point(parameters[0], parameters[1])\n        );\n    }\n    static getParameterCount () {\n        return 2;\n    }\n    toString() {\n        return `L${this.end.x},${this.end.y}`;\n    }\n    slice (t) {\n        const end = Point.weightedAverage([this.begin, (1-t)], [this.end, t]);\n        return new AbsLineCommand(this.previous, end);\n    }\n}\n\nexport class RelLineCommand extends Command {\n    constructor (previous, endRel=null) {\n        super(previous);\n\n        this.endRel = endRel;\n    }\n    static fromParameters (previous, parameters) {\n        return new RelLineCommand(\n            previous,\n            new Vector(parameters[0], parameters[1])\n        );\n    }\n    static getParameterCount () {\n        return 2;\n    }\n    get end () {\n        return this.previous.end.plus(this.endRel);\n    }\n    toString() {\n        return `l${this.endRel.x},${this.endRel.y}`;\n    }\n    slice (t) {\n        const endRel = this.endRel.times(t);\n        const slice = new RelLineCommand(this.previous, endRel);\n        return slice;\n    }\n}\n\nexport class AbsCubicSplineCommand extends Command {\n    constructor (previous, handle1=null, handle2=null, end=null) {\n        super(previous);\n\n        this.handle1 = handle1;\n        this.handle2 = handle2;\n        this.end = end;\n    }\n    static fromParameters (previous, parameters) {\n        return new AbsCubicSplineCommand(\n            previous,\n            new Point(parameters[0], parameters[1]),\n            new Point(parameters[2], parameters[3]),\n            new Point(parameters[4], parameters[5])\n        );\n    }\n    static getParameterCount () {\n        return 6;\n    }\n    toString() {\n        return `C${this.handle1.x},${this.handle1.y} ${this.handle2.x},${this.handle2.y} ${this.end.x},${this.end.y}`;\n    }\n    slice (t) {\n\n        // ⎡ A' ⎤ = ⎡ 1       0         0         0  ⎤ ⎡ A ⎤\n        // ⎢ B' ⎥ = ⎢ (1-t)   t         0         0  ⎥ ⎢ B ⎥\n        // ⎢ C' ⎥ = ⎢ (1-t)²  (1-t)t    t²        0  ⎥ ⎢ C ⎥\n        // ⎣ D' ⎦ = ⎣ (1-t)³  3t(1-t)²  3t²(1-t)  t³ ⎦ ⎣ D ⎦\n\n        // Alias variables so the code matches the math\n        const A = this.begin;\n        const B = this.handle1;\n        const C = this.handle2;\n        const D = this.end;\n\n        // Also alias the powers of `t` because the power operator isn't supported\n        // everywhere and Math.pow() looks ugly\n        const t_sq = t * t;\n        const t_cu = t * t_sq;\n        const t_inv = 1 - t;\n        const t_inv_sq = t_inv * t_inv;\n        const t_inv_cu = t_inv * t_inv_sq;\n\n        // By the way, I've checked the order of operations on * versus ** (exponenentiation).\n        // It follows Please-Excuse-My-Dear-Aunt-Sally as one would expect. It's fine.\n\n        const handle1 = Point.weightedAverage( [A, t_inv   ], [B,   t         ]                               );\n        const handle2 = Point.weightedAverage( [A, t_inv_sq], [B, 2*t*t_inv   ], [C,   t_sq]                  );\n        const end     = Point.weightedAverage( [A, t_inv_cu], [B, 3*t*t_inv_sq], [C, 3*t_sq*t_inv], [D, t_cu] );\n\n        return new AbsCubicSplineCommand(this.previous, handle1, handle2, end);\n    }\n    interpolate (t) {\n        const t_sq = t * t;\n        const t_cu = t * t_sq;\n        const t_inv = 1 - t;\n        const t_inv_sq = t_inv * t_inv;\n        const t_inv_cu = t_inv * t_inv_sq;\n\n        const A = this.begin;\n        const B = this.handle1;\n        const C = this.handle2;\n        const D = this.end;\n\n        return Point.weightedAverage( [A, t_inv_cu], [B, 3*t*t_inv_sq], [C, 3*t_sq*t_inv], [D, t_cu] );\n    }\n    estimateLength() {\n        // Use 4 interpolated segments to estimate\n        const intermediate1 = this.interpolate(0.25);\n        const intermediate2 = this.interpolate(0.50);\n        const intermediate3 = this.interpolate(0.75);\n\n        return intermediate1.minus(this.begin).length +\n            intermediate2.minus(intermediate1).length +\n            intermediate3.minus(intermediate2).length +\n            this.end.minus(intermediate3).length;\n    }\n}\n\nexport class RelCubicSplineCommand extends AbsCubicSplineCommand {\n    constructor (previous, handle1Rel=null, handle2Rel=null, endRel=null) {\n        super(previous);\n\n        this.handle1Rel = handle1Rel;\n        this.handle2Rel = handle2Rel;\n        this.endRel = endRel;\n    }\n    static fromParameters (previous, parameters) {\n        return new RelCubicSplineCommand(\n            previous,\n            new Vector(parameters[0], parameters[1]),\n            new Vector(parameters[2], parameters[3]),\n            new Vector(parameters[4], parameters[5])\n        );\n    }\n    static getParameterCount () {\n        return 6;\n    }\n    toString() {\n        return `c${this.handle1Rel.x},${this.handle1Rel.y} ${this.handle2Rel.x},${this.handle2Rel.y} ${this.endRel.x},${this.endRel.y}`;\n    }\n\n    // Create getters to wrap the properties\n    get handle1 () { return this.begin.plus(this.handle1Rel); }\n    get handle2 () { return this.begin.plus(this.handle2Rel); }\n    get end     () { return this.begin.plus(this.endRel); }\n\n    // Black-hole setters so the parent class can assign to this property\n    set handle1 (_) { }\n    set handle2 (_) { }\n    set end     (_) { }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/pathDataCommands.js\n// module id = 4\n// module chunks = 0","import asyncExec, { timeout } from './lib/asyncExec';\nimport { parsePathData } from './lib/pathParser';\nimport { assertType } from './lib/util';\n\nfunction animatePath(path, config={}) {\n    assertType('path', path, SVGPathElement);\n\n    let pausePromise = null;    // When set, execution waits until the promise resolves\n    let unpause = null;         // Callback to resolve pausePromise, resuming execution \n    let shouldStop = false;     // Flag to halt execution gracefully\n\n    // Animation daemon\n    asyncExec(function*() {\n        const originalPathData = path.getAttribute('d');\n        const commands = Array.from(parsePathData(originalPathData));\n\n        try {\n            let completedCommandString = '';\n            for (let command of commands) {\n                if (command.hasLength()) {\n                    const duration = config.millisPerSegment\n                        || (config.millisPerPixel && config.millisPerPixel * command.estimateLength())\n                        || 100;\n\n                    const begin = +(new Date());\n\n                    for (let progress = 0; progress < 1.0; progress = (new Date() - begin)/duration) {\n                        const slicedCommand = command.slice(progress);\n                        path.setAttribute('d', completedCommandString + slicedCommand);\n\n                        if (pausePromise) {\n                            yield pausePromise;\n                        } else {\n                            // Delay so GUI can render\n                            // yield timeout(50); // 20 fps?\n                            yield timeout(0); // as smooth as possible\n                        }\n\n                        if (shouldStop) {\n                            return;\n                        }\n                    }\n                }\n                completedCommandString += command;\n            }\n        } finally {\n            path.setAttribute('d', originalPathData);\n        }\n    });\n\n    // Animation Controller\n    return {\n        pause() {\n            if (!pausePromise) {\n                pausePromise = new Promise(resolve => {\n                    unpause = resolve;\n                });\n            }\n        },\n        resume() {\n            if (pausePromise) {\n                unpause();\n\n                unpause = null;\n                pausePromise = null;\n            }\n        },\n        reset() {\n            shouldStop = true;\n            this.resume();\n        },\n    };\n}\n\nwindow.animatePath = animatePath;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./main.js\n// module id = 5\n// module chunks = 0"],"sourceRoot":""}